/*
 * Generated by ChatGPT
 * @description RSA-OAEP (SHA-256 by default) helpers using the Web Crypto API.
 * No third-party deps. Designed for browsers.
 *
 * Exports:
 *  - encryptAesKeyOAEP(aesKey, pemPublicKey, opts?)
 */

 type RsaOaepHash = 'SHA-256' | 'SHA-1' | 'SHA-384' | 'SHA-512'

/** Utility: ensure Web Crypto is present */
function getSubtle(): SubtleCrypto {
  // In modern browsers, window.crypto.subtle exists.
  if (typeof crypto !== 'undefined' && crypto.subtle)
    return crypto.subtle
  throw new Error('[crypto.ts] Web Crypto API is unavailable in this runtime')
}

/**
 * Robust PEM → ArrayBuffer
 * - Accepts "-----BEGIN PUBLIC KEY-----" (SPKI) PEM.
 * - Tolerates extra spaces/CRLFs.
 * - Accepts URL-safe base64 ("-_/" variants) and fixes missing padding.
 */
function pemToArrayBuffer(pem: string): ArrayBuffer {
  if (!pem || typeof pem !== 'string') {
    throw new TypeError('[pemToArrayBuffer] pem must be a non-empty string')
  }

  // Fast check for supported header. We explicitly support SPKI public keys.
  const isSpki = /-----BEGIN\s+PUBLIC\s+KEY-----/.test(pem)
  const isPkcs1 = /-----BEGIN\s+RSA\s+PUBLIC\s+KEY-----/.test(pem)

  if (!isSpki && isPkcs1) {
    // Web Crypto requires SPKI for public-key import. PKCS#1 (RSA PUBLIC KEY)
    // is not supported directly, so we fail early with a clear message.
    throw new Error(
      '[pemToArrayBuffer] Provided PEM looks like PKCS#1 ("BEGIN RSA PUBLIC KEY"). '
      + 'Please provide an SPKI public key ("BEGIN PUBLIC KEY").',
    )
  }

  // Remove header/footer and all whitespace
  let b64 = pem
    .replace(/-----BEGIN[^-]+-----/g, '')
    .replace(/-----END[^-]+-----/g, '')
    .replace(/\s+/g, '')
    .trim()

  if (!b64)
    throw new Error('[pemToArrayBuffer] Empty base64 payload after stripping PEM headers')

  // Handle URL-safe base64 variants
  b64 = b64.replace(/-/g, '+').replace(/_/g, '/')

  // Fix missing padding if needed
  const pad = b64.length % 4
  if (pad === 2)
    b64 += '=='
  else if (pad === 3)
    b64 += '='
  else if (pad !== 0)
    throw new Error('[pemToArrayBuffer] Invalid base64 length')

  const binary = typeof atob === 'function' ? atob(b64) : base64Decode(b64)
  const buf = new ArrayBuffer(binary.length)
  const view = new Uint8Array(buf)
  for (let i = 0; i < binary.length; i++) view[i] = binary.charCodeAt(i)
  return buf
}

/**
 * Import an RSA public key from SPKI PEM for RSA-OAEP.
 * Default hash is SHA-256.
 */
async function importRsaPublicKeyFromPem(
  pem: string,
  hash: RsaOaepHash = 'SHA-256',
): Promise<CryptoKey> {
  const subtle = getSubtle()
  const keyBuffer = pemToArrayBuffer(pem)
  try {
    return await subtle.importKey(
      'spki',
      keyBuffer,
      { name: 'RSA-OAEP', hash },
      false,
      ['encrypt'],
    )
  }
  catch (e) {
    // Provide helpful diagnostics
    const err = e as Error
    throw new Error(
      `[importRsaPublicKeyFromPem] Failed to import SPKI public key for RSA-OAEP (${hash}). `
      + `Reason: ${err.message}. Ensure the PEM is an SPKI public key (BEGIN PUBLIC KEY) and not PKCS#1.`,
    )
  }
}

interface EncryptOAEPOptions {
  /** OAEP hash algorithm, defaults to 'SHA-256' */
  hash?: RsaOaepHash
  /** If true, retry with SHA-1 when SHA-256 import/encrypt fails (compat fallback) */
  allowSha1Fallback?: boolean
  /** Return format for ciphertext, defaults to 'base64' */
  output?: 'base64' | 'uint8' | 'arrayBuffer'
}

/**
 * Encrypt an AES key (string or bytes) with RSA-OAEP.
 * - Uses SHA-256 by default (matches Node.js crypto privateDecrypt oaepHash: 'sha256').
 * - Returns base64 by default, or Uint8Array/ArrayBuffer per opts.output.
 * - Includes optional SHA-1 fallback for legacy servers (set allowSha1Fallback = true).
 */
export async function encryptAesKeyOAEP(
  aesKey: string | Uint8Array,
  pemPublicKey: string,
  opts: EncryptOAEPOptions = {},
): Promise<string | Uint8Array | ArrayBuffer> {
  const hash = opts.hash ?? 'SHA-256'
  const subtle = getSubtle()

  const plainBytes = typeof aesKey === 'string' ? new TextEncoder().encode(aesKey) : aesKey as Uint8Array<ArrayBuffer>

  const tryEncrypt = async (algo: RsaOaepHash): Promise<ArrayBuffer> => {
    const pub = await importRsaPublicKeyFromPem(pemPublicKey, algo)
    return subtle.encrypt({ name: 'RSA-OAEP' }, pub, plainBytes)
  }

  let ciphertext: ArrayBuffer
  try {
    ciphertext = await tryEncrypt(hash)
  }
  catch (e) {
    if (opts.allowSha1Fallback && hash !== 'SHA-1') {
      // Retry with SHA-1 for maximum interoperability if explicitly allowed.
      ciphertext = await tryEncrypt('SHA-1')
    }
    else {
      throw e
    }
  }

  if (opts.output === 'arrayBuffer')
    return ciphertext
  const u8 = new Uint8Array(ciphertext)
  if (opts.output === 'uint8')
    return u8
  return toBase64(u8) // default base64 for transport
}

/** Encode Uint8Array → base64 */
function toBase64(u8: Uint8Array): string {
  let binary = ''
  for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i])
  return typeof btoa === 'function' ? btoa(binary) : base64Encode(binary)
}

// --- Minimal base64 encode/decode polyfills for non-browser runtimes ---
function base64Encode(binary: string): string {
  // This is only used if btoa is not available; kept simple for completeness.
  // In browsers, btoa will be used instead.
  // eslint-disable-next-line node/prefer-global/buffer
  if (typeof Buffer !== 'undefined') {
    // eslint-disable-next-line node/prefer-global/buffer
    return Buffer.from(binary, 'binary').toString('base64')
  }
  throw new Error('[base64Encode] No btoa/Buffer available')
}

function base64Decode(b64: string): string {
  // eslint-disable-next-line node/prefer-global/buffer
  if (typeof Buffer !== 'undefined') {
    // eslint-disable-next-line node/prefer-global/buffer
    return Buffer.from(b64, 'base64').toString('binary')
  }
  throw new Error('[base64Decode] No atob/Buffer available')
}
